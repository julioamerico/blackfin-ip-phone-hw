#!/usr/bin/expect
#
# Copyright (C) 2004 Bruce Giese
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
#
# Revision history
# 10/25/04  Bruce Giese     first checked into cvs
# 11/23/04  Bruce Giese     various minor improvements and feature changes
#
#
#  This program performs substantial u-boot functional testing.
#




#
#  This procedure converts a string spit out by "time" to a value
#  in seconds (with decimal places).  The input is in microseconds.
#
proc convert_to_seconds {before_conversion} {

   # remove the text string after the number
   set c_t_s_number [lindex $before_conversion 0]

   set c_t_s_length [string length $c_t_s_number]

   set c_t_s_retval 9999

   if { $c_t_s_length > 6} {

      # we're dealing in seconds
      set c_t_s_seconds [string range $c_t_s_number 0 \
[expr $c_t_s_length - 7]]
      set c_t_s_decimals [string range $c_t_s_number \
[expr $c_t_s_length - 6] end]
      set c_t_s_retval "$c_t_s_seconds.$c_t_s_decimals"
   } else {

         # we're dealing in something less than 1 second
         set c_t_s_x "000000"
         set c_t_s_retval ".[string range $c_t_s_x 0 \
[expr 5 - $c_t_s_length]]$c_t_s_number"
   }
   return $c_t_s_retval
}




#
#  These are equivalent to the tee command. Send a message to both
#      to the console
#      to the log file
#
proc report { message } {
   puts \n$message
   send_log "\n$message\n"
}

#  This simply doesn't add line feeds.
proc send_both {message} {
   send_log $message
   puts -nonewline $message
}




#
#  This attempts to recover from losing contact with uboot.
#  Just send a Control-C and then wait briefly.
#
proc recover {} {
   send "\3"
   sleep 2
}




#
#  This waits for a uboot prompt and then continues on.
#
#
proc wait_for_uboot {} {
   global UBOOT_PROMPT

   puts "waiting for uboot prompt"
   send_log "waiting for uboot prompt"
   set timeout_flag 0
   while 1 {
      expect {

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: Never got uboot prompt, will attempt to recover"
            set timeout_flag 1
            # send a Control-C
            send "\3"
            break
         }
      }
   }
   if { $timeout_flag == 1 } {
      while 1 {
         expect {

            $UBOOT_PROMPT {
               report "recovery worked"
               break
            }

            timeout {
               report "ERROR: Wasn't able to recover, will try again"
               recover
               break
            }
         }
      }
   }
}




#
#  Call this procedure to record the result of a test
#    These two procedures are exactly the same, but can't
#    be collapsed due to how params are passed (by value only).
#
#
proc record_test_result { test_num result } {
   global result_matrix
# Get the row associated with test_num.
   set temp_2_element_matrix [lindex $result_matrix $test_num]
# Set the 2nd element to result.
   set temp_2_element_matrix [lreplace $temp_2_element_matrix 1 1 $result]
# Write it back into the matrix.
   set result_matrix [lreplace $result_matrix $test_num $test_num $temp_2_element_matrix]

   set x [lindex $result_matrix $test_num]
   set y [lindex $x 0]
   set z [lindex $x 1]
   report "===== Recording result: $y is $z"
}


#
#  Call this procedure to record a test measurement
#    These two procedures are exactly the same, but can't
#    be collapsed due to how params are passed (by value only).
#
proc record_test_measurement { test_num result } {
   global measurement_matrix
# Get the row associated with test_num.
   set temp_2_element_matrix [lindex $measurement_matrix $test_num]
# Set the 2nd element to result.
   set temp_2_element_matrix [lreplace $temp_2_element_matrix 1 1 $result]
# Write it back into the matrix.
   set measurement_matrix [lreplace $measurement_matrix $test_num $test_num $temp_2_element_matrix]

   set x [lindex $measurement_matrix $test_num]
   set y [lindex $x 0]
   set z [lindex $x 1]
   report "===== Recording measurement: $y is $z"
}





#
#  Call this procedure instead of doing an exit so we can
#  do any cleanup needed.  Note that we use a temporary
#  logfile for bulk data and a summary logfile which is
#  never overwritten.
#
proc all_done { } {
   global result_matrix
   global measurement_matrix
   global summary_logfile
   global TEST_PASS
   global TEST_FAIL
   global TEST_INFO
   global ttydev
   global output_pin
   global target_ip_addr
   global BOARD_TYPE
   global HOST_IP_ADDR
   global test_started

# Capture the information into a special logfile for an email
   log_file
   log_file -noappend $summary_logfile
   puts "\nsending summary results to $summary_logfile\n"

   set total_tests 0
   set passed_tests 0
   set failed_tests 0
   set tests_not_run 0

   send_both "\ntest started $test_started\n\n"
   send_both "Test Results\n"
   send_both "=====================================\n"

   for {set i [expr [llength $result_matrix]-1]} {$i>=0} {incr i -1} {

      incr total_tests
      set x [lindex $result_matrix $i]
      if {$TEST_PASS == [lindex $x 1]} {
         incr passed_tests
      }
      if {$TEST_FAIL == [lindex $x 1]} {
         incr failed_tests
      }
      if {$TEST_INFO == [lindex $x 1]} {
         incr tests_not_run
      }
   }
   send_both "  Total Tests   :   $total_tests\n"
   send_both "  Passed Tests  :   $passed_tests\n"
   send_both "  Failed Tests  :   $failed_tests\n"
   send_both "  Tests Not Run :   $tests_not_run\n"
   send_both "\n"
   send_both "Failed Tests\n"
   send_both "=====================================\n"

   for {set i [expr [llength $result_matrix]-1]} {$i>=0} {incr i -1} {
      set x [lindex $result_matrix $i]
      if {$TEST_FAIL == [lindex $x 1]} {
         send_both "  -  [lindex $x 0]\n"
      }
   }

   send_both "\n"
   send_both "Passing Tests\n"
   send_both "=====================================\n"
   for {set i [expr [llength $result_matrix]-1]} {$i>=0} {incr i -1} {
      set x [lindex $result_matrix $i]
      if {$TEST_PASS == [lindex $x 1]} {
         send_both "  -  [lindex $x 0]\n"
      }
   }

   send_both "\n"
   send_both "Tests Not Run\n"
   send_both "=====================================\n"
   for {set i [expr [llength $result_matrix]-1]} {$i>=0} {incr i -1} {
      set x [lindex $result_matrix $i]
      if {$TEST_INFO == [lindex $x 1]} {
         send_both "  -  [lindex $x 0]\n"
      }
   }

   send_both "\n"
   send_both "Measurement Tests\n"
   send_both "=====================================\n"

   for {set i [expr [llength $measurement_matrix]-1]} {$i>=0} {incr i -1} {
      set x [lindex $measurement_matrix $i]
      set y [lindex $x 0]
      if {$TEST_INFO == [lindex $x 1]} {
         set z "not measured"
      } else {
         set z [lindex $x 1]
      }
      send_both "  $y = $z\n"
   }

   send_both "\n"
   send_both "Test Setup\n"
   send_both "=====================================\n"
   send_both "  board type = $BOARD_TYPE\n"
   send_both "  tty = $ttydev\n"
   send_both "  output pin = $output_pin\n"
   send_both "  target ip addr = $target_ip_addr\n"
   send_both "  host ip addr   = $HOST_IP_ADDR\n"

   # We never return back to the main program.
   exit
}



#
#  This procedure executes a test to copy memory from one location
#  to another: RAM-to-RAM, flash-to-flash, RAM-to-flash, flash-to-RAM.
#  The interface is ugly, but it works.
#
#  from_loc           where to copy the data from (just hex digits, no 0x)
#  from _type         flash or RAM?
#  to_loc             where to cpoy the data to (just hex digits, no 0x)
#  to_type            flash or RAM?
#  to_loc_minus_4     to avoid painful hex arithmetic, just tell me this value
#                     again, just hex digits, no 0x
#  to_loc_plus_size   to avoid painful hex arithmetic, just tell me this value
#                     again, just hex digits, no 0x
#  size               number of bytes to copy (hex digits, no 0x)
#  size_decimal       size expressed in decimal (sorry, too lazy to convert it)
#  flash_from_erase_start  if from_type is flash, this says where to erase
#                     NOTE:  flash_erase_start < to_loc-4
#                     just hex digits
#  flash_from_erase_end    if from_type is flash, this says where to erase
#                     NOTE:  flash_erase_end > to_loc+size+4
#                     just hex digits#
#  flash_to_erase_start  if to_type is flash, this says where to erase
#                     NOTE:  flash_erase_start < to_loc-4
#                     just hex digits
#  flash_to_erase_end    if to_type is flash, this says where to erase
#                     NOTE:  flash_erase_end > to_loc+size+4
#                     just hex digits
#
#  return value       pass/fail/info
#
#  The test binary file should be larger than size and should not contain
#  any bytes with the value FF.
#
proc copy_test {from_loc from_type to_loc to_type to_loc_minus_4 \
to_loc_plus_size size size_decimal flash_from_erase_start \
flash_from_erase_end flash_to_erase_start flash_to_erase_end} {

   global COPY_TEST_FLASH
   global COPY_TEST_RAM
   global TEST_BIN_FILE
   global TEST_FAIL
   global TEST_PASS
   global TEST_INFO
   global UBOOT_PROMPT
   global SUCCESS
   global FAILURE

   set TFTP_ATTEMPTS 3
   set ERASE_ATTEMPTS 3
   set COPY_ATTEMPTS 3

   report "preparing to copy from 0x$from_loc to 0x$to_loc"

   # convert critical strings to lower case to avoid pattern match errors.
   set to_loc_minus_4 [string tolower $to_loc_minus_4]
   set to_loc_plus_size [string tolower $to_loc_plus_size]

#
# FROM
#

   if {$from_type == $COPY_TEST_FLASH} {

      report "We're copying from flash"

      set timeout 120
      set tftp_flag $FAILURE

      # Make multiple attempts to do tftp.
      for {set i 0} {$i<$TFTP_ATTEMPTS && $tftp_flag==$FAILURE} {incr i} {
         send "tftp 0x1000000 $TEST_BIN_FILE\r"
         while 1 {
            expect {

               "#" { }

               "done" {
                  set tftp_flag $SUCCESS
               }

               $UBOOT_PROMPT {
                  break
               }

               timeout {
                  report "ERROR: Uboot locked up during tftp"
                  recover
                  break
               }
            }
         }
      }

      if { $tftp_flag == $FAILURE } {
         report "INFO: Can't execute cp test because tftp didn't work."
         return $TEST_INFO
      }

      set timeout 480
      set erase_flag $FAILURE
      set copy_flag  $FAILURE

      # Make multiple attempts at erasing flash and copying to it.
      for {set i 0} {$i<$COPY_ATTEMPTS && $copy_flag==$FAILURE} {incr i} {
         for {set k 0} {$k<$ERASE_ATTEMPTS && $erase_flag==$FAILURE} {incr k} {
            send "erase $flash_from_erase_start $flash_from_erase_end\r"
            while 1 {
               expect {

                  "done" {
                     send_log "\ngot done indicator\n"
                     set erase_flag $SUCCESS
                  }

                  -re "Erased \[0-9]+ sectors" {
                     send_log "\ngot Erased N sectors indicator\n"
                     set erase_flag $SUCCESS
                  }

                  $UBOOT_PROMPT {
                     break
                  }

                  timeout {
                     report "ERROR: erase failed during test"
                     recover
                     return $TEST_INFO
                  }
               }
            }
         }

         if {$erase_flag==$FAILURE} {
            report "ERROR: failed to erase flash, can't run cp test"
            return $TEST_INFO
         }

         # move the test data into the from location of flash.
         set timeout 300
         send "cp.b 0x1000000 0x$from_loc 0x$size\r"

         while 1 {
            expect {
   
               "done" {
                  send_log "\ncopy to flash successful\n"
                  set copy_flag $SUCCESS
               }

               $UBOOT_PROMPT {
                  break
               }

               timeout {
                  report "ERROR: cp.b timed out"
                  recover
                  return $TEST_FAIL
               }
            }
         }
      }
      if {$copy_flag == $FAILURE} {
         report "ERROR: can't copy data into the from flash location"
         return $TEST_INFO
      }

   } else {

      report "We're copying from RAM"
      set timeout 120
      set tftp_flag $FAILURE

      # Make multiple attempts to do tftp.
      for {set i 0} {$i<$TFTP_ATTEMPTS && $tftp_flag==$FAILURE} {incr i} {

         send "tftp 0x$from_loc $TEST_BIN_FILE\r"
         while 1 {
            expect {

               "#" { }

               "done" {
                  set tftp_flag $SUCCESS
               }

               $UBOOT_PROMPT {
                  break
               }

               timeout {
                  report "ERROR: Uboot locked up during tftp"
                  recover
                  break
               }
            }
         }
      }
      if { $tftp_flag == $FAILURE } {
         report "INFO: Can't execute cp test because tftp didn't work."
         return $TEST_INFO
      }
   }

#
# TO
#

   if {$to_type == $COPY_TEST_FLASH} {

      report "We're copying to flash"
      set timeout 480
      set erase_flag $FAILURE
      for {set i 0} {$i<$ERASE_ATTEMPTS && $erase_flag==$FAILURE} {incr i} {

         send "erase 0x$flash_to_erase_start 0x$flash_to_erase_end\r"
         while 1 {
            expect {

               "done" {
                  set erase_flag $SUCCESS
               }

               $UBOOT_PROMPT {
                  break
               }

               timeout {
                  report "ERROR: erase failed during test"
                  recover
                  break
               }
            }
         }
      }
      if {$erase_flag==$FAILURE} {
         report "ERROR: failed to erase flash, can't run cp test"
         return $TEST_INFO
      }

   } else {

      report "We're copying to RAM"
      # change the bytes immediately preceding to_loc to FF

      set timeout 5
      send "mw.b 0x$to_loc_minus_4 0xFFFFFFFF 4\r"
      expect $UBOOT_PROMPT

      set timeout 5
      set flag 0
      send "md.b 0x$to_loc_minus_4\r"
      while 1 {
         expect {

            "$to_loc_minus_4:*ff ff ff ff" {
               set flag 1
            }

            $UBOOT_PROMPT {
               break
            }

            timeout {
               report "ERROR: md failed during test"
               recover
               break
            }
         }
      }
      if {$flag == 0} {
         report "ERROR: md doesn't work correctly, can't run cp test"
         return $TEST_INFO
      }

      # This never seems to fail, so don't do multiple attempts.
      set timeout 5
      send "mw.b 0x$to_loc_plus_size 0xFF 4\r"
      expect $UBOOT_PROMPT

      set timeout 5
      set flag 0
      send "md.b 0x$to_loc_plus_size\r"
      while 1 {
         expect {

            "$to_loc_plus_size: ff ff ff ff" {
               set flag 1
            }

            $UBOOT_PROMPT {
               break
            }

            timeout {
               report "ERROR: md failed during test"
               recover
               break
            }
         }
      }
      if {$flag == 0} {
         report "ERROR: md doesn't work correctly, can't run cp test"
         return $TEST_INFO
      }
   }

#
# COPY
#

   set timeout 300
   send "cp.b  0x$from_loc 0x$to_loc 0x$size\r"

   while 1 {
      expect {

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: cp.b timed out"
            recover
            return $TEST_FAIL
         }
      }
   }

   set timeout 5
   set compare_flag $TEST_FAIL
   send "cmp.b  0x$from_loc 0x$to_loc 0x$size\r"

   while 1 {
      expect {

         "$size_decimal*ytes" {
            report "all the copied bytes compare correctly"
            set compare_flag $TEST_PASS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: cp.b timed out"
            recover
            return $TEST_FAIL
         }
      }
   }
   if {$compare_flag == $TEST_FAIL} {
      return $TEST_FAIL
   }

   report "We're looking for $to_loc_minus_4: ffffffff"
   set before_check_flag $TEST_FAIL
   set timeout 5
   send "md.b 0x$to_loc_minus_4\r"
   while 1 {
      expect {

         "$to_loc_minus_4: ff ff ff ff" {
            report "bytes before the copy location were correctly not modified"
            set before_check_flag $TEST_PASS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: md command failed, can't run cp test"
            recover
            return $TEST_INFO
         }
      }
   }

   report "We're looking for $to_loc_plus_size: ffffffff"
   set after_check_flag $TEST_FAIL
   set timeout 5
   send "md.b 0x$to_loc_plus_size\r"
   while 1 {
      expect {

         "$to_loc_plus_size: ff ff ff ff" {
            report "bytes after the copy location were correctly not modified"
            set after_check_flag $TEST_PASS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: md command failed, can't run cp test"
            recover
            return $TEST_INFO
         }
      }
   }

   if {$before_check_flag==$TEST_PASS && $after_check_flag==$TEST_PASS} {
      return $TEST_PASS
   } else {
      return $TEST_FAIL
   }
}




#
#  Step
#
#  This procedure delineates steps in the testing within the
#  log file and screen output.
#
#
proc step { message } {
  global step_sequence_number

  puts "\n*******************************************************************"
  puts "STEP $step_sequence_number: $message\n\n"
  send_log "STEP $step_sequence_number: $message\n\n"
  incr step_sequence_number 
}




#
#
#   Main Program
#
#   uboot test script
#
#   This script has several requirements in order to run it.
#     1)  You need a parallel port cable hacked up with one of the data
#         pins [pins 2-9] going to the side of the resistor R58 pads
#         which connect to the ADI chip on the board.  Eventually, this
#         requirement will be dropped in favor of using the reset command.
#     2)  You need a valid uImage, linux.dxe, autoscr file, and testfile.bin
#         in the host /tftpboot.  The names can be changed in the definitions
#         below.  You will need to add the details of these files into the
#         definitions below for the tests to work.  autoscr must contain
#         commands to echo text out to the console (and the text must be
#         defined below).
#     3)  The host must be set up to be a tftp server.
#     4)  You need the autoscript test file uboot-autoscr-test.img on
#         the host /tftpboot
#     5)  You need a functional kermit application in your path.
#     6)  uboot must already be loaded on your board.
#     7)  The countdown timer in uboot must be set to at least 7.
#     8)  Unfortunately, the script is written assuming 0x1000000 is
#         available as scratch memory.  If not, you'll need to do a
#         lot of modifications.
#     9)  You'll need to modify the definitions for flash memory.
#     10) There are probably other assumptions.
#
#


# There are rational reasons for defining these things like this.
# It avoids SUBTLE errors with misspelling in favor of big, obvious errors.
set SUCCESS                 "success"
set FAILURE                 "failure"
set WARNING                 "warning"
set TEST_PASS               "pass"
set TEST_FAIL               "fail"
# Note that the TEST_INFO value must match the tables below. Sorry.
set TEST_INFO               "notrun"

# These are arguments to the copy_test procedure above.
set COPY_TEST_FLASH         1
set COPY_TEST_RAM           2

#
#  This matrix contains all the tests which are run.  Note that
#  The second column must match the value of TEST_INFO above.  Also,
#  The indexes below must align with the location of the test.
#  Don't thank me for that; nothing in curly brackets gets
#  evaluated in expect so there appears to be no other way.
#
set mtest_loc                           0
set version_loc                         1
set echo_loc                            2
set help_date_loc                       3
set date_set_loc                        4
set date_set_after_power_cycle_loc      5
set time_set_after_power_cycle_loc      6
set help_loc                            7
set flinfo_bank_count_loc               8
set flinfo_mfgr_loc                     9
set mwl_loc                             10
set nm_loc                              11
set mm_loc                              12
set reset_loc                           13
set savenv_loc                          14
set ping_loc                            15
set autoscr_loc                         16
set base_loc                            17
set bdinfo_loc                          18
set iminfo_loc                          19
set bootelf_loc                         20
set printenv_loc                        21
set protect_on_loc                      22
set protect_off_loc                     23
set cmp_loc                             24
set run_loc                             25
set tftp_loc                            26
set tftp_errors_loc                     27
set boot_from_flash_loc                 28
set cp_RAM_to_RAM_aligned_loc           29
set cp_RAM_to_RAM_unaligned_loc         30
set cp_RAM_to_flash_aligned_loc         31
set cp_RAM_to_flash_unaligned_loc       32
set cp_flash_to_flash_aligned_loc       33
set cp_flash_to_flash_unaligned_loc     34
set cp_flash_to_RAM_aligned_loc         35
set cp_flash_to_RAM_unaligned_loc       36

set result_matrix { {mtest                                notrun} \
                    {{version}                            notrun} \
                    {echo                                 notrun} \
                    {{help date}                          notrun} \
                    {{date set}                           notrun} \
                    {{date set after power cycle}         notrun} \
                    {{time set after power cycle}         notrun} \
                    {help                                 notrun} \
                    {{flinfo bank count}                  notrun} \
                    {{flinfo mfgr}                        notrun} \
                    {mw                                   notrun} \
                    {nm                                   notrun} \
                    {mm                                   notrun} \
                    {reset                                notrun} \
                    {savenv                               notrun} \
                    {ping                                 notrun} \
                    {autoscr                              notrun} \
                    {base                                 notrun} \
                    {bdinfo                               notrun} \
                    {iminfo                               notrun} \
                    {bootelf                              notrun} \
                    {printenv                             notrun} \
                    {{protect on}                         notrun} \
                    {{protect off}                        notrun} \
                    {cmp                                  notrun} \
                    {run                                  notrun} \
                    {tftp                                 notrun} \
                    {{tftp check for errors}              notrun} \
                    {{boot known-good uImage from flash}  notrun} \
                    {{cp RAM-to-RAM, aligned}             notrun} \
                    {{cp RAM-to-RAM, unaligned}           notrun} \
                    {{cp RAM-to-flash, aligned}           notrun} \
                    {{cp RAM-to-flash, unaligned}         notrun} \
                    {{cp flash-to-flash, aligned}         notrun} \
                    {{cp flash-to-flash, unaligned}       notrun} \
                    {{cp flash-to-RAM, aligned}           notrun} \
                    {{cp flash-to-RAM, unaligned}         notrun}}

#
#  This matrix is similar to the one above, but it contains
#  measurements rather than pass/fail results.
#
set boot_seconds_loc                     0
set max_saveenv_time_loc                 1
set min_saveenv_time_loc                 2
set ave_saveenv_time_loc                 3
set ping_command_time_max_loc            4
set ping_command_time_min_loc            5
set ping_command_time_ave_loc            6

set measurement_matrix { \
                    {{one boot countdown second}         notrun} \
                    {{max saveenv time, in seconds}      notrun} \
                    {{min saveenv time, in seconds}      notrun} \
                    {{ave saveenv time, in seconds}      notrun} \
                    {{max ping command time, in seconds} notrun} \
                    {{min ping command time, in seconds} notrun} \
                    {{ave ping command time, in seconds} notrun}}


set LOG_DIR                 "/home/bfarm/logs"
set SCRIPT_DIR              "/home/bfarm/bin"

# we use the output pin number in the target IP address which is set below.
# this is to support a board farm with lots of stamp boards.
set HOST_IP_BASE            "192.168.1"
set HOST_IP_ADDR            "$HOST_IP_BASE.1"
set TFTP_LOAD_ADDR          "0x1000000"
set SERIAL_PORT_BAUD_RATE   "57600"

set FLASH_MFGR              "ST Microelectronics"
set NUMBER_OF_FLASH_BANKS   67

# Choose which type of board you have.
set BOARD_TYPE              "stamp_config"
#set BOARD_TYPE              "ezkit_config"

set AUTOSCR_TEST_FILE       "uboot-autoscr-test.img"
# the autoscr file above will echo the characters below.
set AUTOSCR_TEST_RESULT     "hello Robin"

set LINUX_DXE_FILE          "linux.dxe"

set BASE_RESULT             "0x00000000"

# The test bin file can by anything roughly 100,000 bytes decimal
# HOWEVER, the binary should not contain any FF bytes.
set TEST_BIN_FILE           "testfile.bin"


set BDINFO_MEMSTART         "0x00000000"
set BDINFO_MEMSIZE          "0x08000000"
set BDINFO_FLASHSTART       "0x20000000"
set BDINFO_FLASHSIZE        "0x00400000"
set BDINFO_FLASHOFFSET      "0x00000000"
set BDINFO_BAUDRATE         $SERIAL_PORT_BAUD_RATE

# Specify the detailed settings in your uImage file to be used below.
set KERNEL_GZ_FILENAME      "uImage-$BOARD_TYPE"
set KERNEL_GZ_NAME          "uClinux Kernel Image"
set KERNEL_GZ_DATE          "2004\-08\-20  15:25:26 UTC"
set KERNEL_GZ_TYPE          "Blackfin uClinux Kernel Image"
set KERNEL_GZ_SIZE          "1117143 Bytes"
set KERNEL_GZ_ADDR          "00001000"
set KERNEL_GZ_ENTRY         "00001000"
set KERNEL_FLASH_LOC        "0x20100000"
set KERNEL_FLASH_END        "0x202FFFFF"
set KERNEL_FLASH_SIZE       "0x120000"

# Number of times to execute the ping command for the ping test.
set PING_ITERATIONS         10
# Needs to be at least 4 but probably not greater than about 1000.
set MM_ITERATIONS           32
# Number of times to execute the reset command for the reset test.
set RESET_ITERATIONS        20
# Number of times to do a tftp for the tftp test.
set TFTP_ITERATIONS         20
# Number of times to test saving environment variables.
set SAVEENV_ITERATIONS      10

set UBOOT_PROMPT            "BOOT> "
set KERNEL_PROMPT           "Sash command shell"

# tftp_errors is important for counting any errors in tftp seen anywhere.
# if this count is not zero, then don't claim tftp passes.
set tftp_errors             0

set step_sequence_number    1
set test_started            "...test was never started"


puts "\nThis program is used to test uboot on a target board."

cd $SCRIPT_DIR

set argc [llength $argv]
if { $argc < 2} {
   puts "Usage:  $argv0  /dev/port  pin \[logfile \[summary-logfile]]"
   puts "   where /dev/port is something like /dev/ttyS0, /dev/ttyUSB0"
   puts "   where pin is the parallel port pin used to reset this board"
   puts ""
   puts "NOTE: This requires a valid $KERNEL_GZ_FILENAME file in /tftpboot"
   puts "It also requires a valid linux.dxe in /tftpboot and other things."
   puts ""
   exit
}
# grab the user selections.
set ttydev         [lindex $argv 0]
set output_pin     [lindex $argv 1]

if { $argc >2 } {
   set logfile     [lindex $argv 2]
} else {
   set logfile "$LOG_DIR/$argv0-[exec date +%b-%d-%G-%H-%M]-detailed-log"
}

if { $argc >3 } {
   set summary_logfile [lindex $argv 3]
} else {
   set summary_logfile "$LOG_DIR/$argv0-[exec date +%b-%d-%G-%H-%M]-summary-log"
}


set target_ip_addr "$HOST_IP_BASE.$output_pin"

set test_started [exec date +%b-%d-%G-%I:%M%P]
log_file $logfile

report "Running u-boot testing on $test_started"
report "ttydev=$ttydev"
report "output pin=$output_pin"
report "logfile=$logfile"
report "target ip addr=$target_ip_addr"


step "Start up kermit on port $ttydev"

# Now set up the kermit parameters.
#  I want these all contained in this file to make it easier for users.
#  This just builds up a list of commands which are sent to kermit.
#
set kparams     [list "set line $ttydev\r"]
lappend kparams "set speed $SERIAL_PORT_BAUD_RATE\r"
lappend kparams "set carrier-watch off\r"
lappend kparams "set handshake none\r"
lappend kparams "set flow-control none\r"
lappend kparams "robust\r"
lappend kparams "set file type bin\r"
lappend kparams "set file name lit\r"
lappend kparams "set rec pack 1000\r"
lappend kparams "set send pack 1000\r"
lappend kparams "set window 5\r"
lappend kparams "set escape 255\r"
set nkparams [llength $kparams]

set timeout 5
spawn kermit
# We need to save the id because resetting the board will overwrite it.
set kermit_spawn_id $spawn_id

while 1 {
	expect {
	        "Type ?" { }
		"ermit>" { break }
		"not found" {
                   report "ERROR: Failed to start up kermit"
                   all_done
		}
		timeout {
                   report "ERROR: Time out starting up kermit"
                   all_done
		}
	}
}

for {set i 0} {$i < $nkparams} {incr i} {
    send [lindex $kparams $i]

    while 1 {
	  expect {
		 "ermit>" { break }

		 "\\?\[A-Z]" {
                    report "ERROR: Failed to set up kermit parameters"
                    all_done
		 }

		 timeout {
                    report "ERROR: Time out setting up kermit parameters"
                    all_done
		 }
	  }
    }
}

send "connect\r"
while 1 {
	expect {
		"ype the escape character*" {
		     break  }
		timeout {
		     puts "\nERROR: Can't connect to serial port\n"
		     exit }
	}
}



step "Reset board"
set timeout 30

spawn ./reset_board_as_root $output_pin
while 1 {
   expect {
      timeout {
         report "ERROR: Failed to reset target board, reset script didn't work"
         all_done
      }
      eof {
         break
      }
   }
}
set spawn_id $kermit_spawn_id




step "Wait for uboot countdown"
while 1 {
   expect {

      "Hit any key to stop" {
         break
      }

      timeout {
         report "ERROR: Failed to reset board, no response"
         all_done
      }
   }
}



#
#  After the reset, let's determine how fast the countdown occurs.
#  This relies on the environment variable bootdelay being equal
#  to at least 7.
#
#  If we see a "7" during the boot countdown, then we figure out the
#  time it takes to get from 7 down to 6.  If we never see a 7, then
#  the bootdelay is too low; it needs to be at least 7.
#
step "Test countdown time period"
set temp_status_flag $TEST_PASS
while 1 {
   expect {
      "7" {
         break
      }

      -re \[012345689] { }

      timeout {
            report "ERROR: u-boot timeout needs to be at least 7"
            set temp_status_flag $TEST_FAIL
            break
      }
   }
}

if {$temp_status_flag==$TEST_PASS} {
   set temp_time [time {
      while 1 {
         expect {
            "6" {
               send "\r"
               break
            }

            timeout {
               report "ERROR: Logic error when timing bootdelay"
               recover
               break
            }
         }
      }
   }]
   set bootsec [convert_to_seconds $temp_time]
   record_test_measurement $boot_seconds_loc $bootsec
}

wait_for_uboot




step "version"
set timeout 5
set uboot_version_result $TEST_FAIL
set gcc_version_result $TEST_FAIL

send "version\r"
while 1 {
   expect {

      -re "U-Boot \[0-9]+.\[0-9]+" {
         set uboot_version_result $TEST_PASS
      }

      -re "gcc version : \[0-9]+.\[0-9]+" {
         set gcc_version_result $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot got lost during the version test"
         recover
         break
      }
   }
}
if {$gcc_version_result==$TEST_PASS && $uboot_version_result==$TEST_PASS} {
   record_test_result $version_loc $TEST_PASS
} else {
   record_test_result $version_loc $TEST_FAIL
}



step "echo"
set ECHO_TEST "We will be doing extensive testing of u-boot today."
set timeout 5
send "echo $ECHO_TEST\r"
set temp_status_flag $TEST_FAIL
while 1 {
   expect {

      $ECHO_TEST {
         set temp_status_flag $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot got lost during the echo test... hahaha"
         recover
         break
      }
   }
}
record_test_result $echo_loc $temp_status_flag



step "help date"
set timeout 5
send "help date\r"
set temp_status_flag $TEST_FAIL
while 1 {
   expect {

      "MMDDhhmm" {
         set temp_status_flag $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot got lost during the help date test"
         recover
         break
      }
   }
}
record_test_result $help_date_loc $temp_status_flag



step "date"
set timeout 6
send "date 021409152003.00\r"
set temp_status_flag $TEST_FAIL
while 1 {
   expect {

      "2003-02-14 (Friday)" {
         puts "  Date is correct"
         set temp_status_flag $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot got lost during the date test"
         recover
         break
      }
   }
}
record_test_result $date_set_loc $temp_status_flag



step "Power off blackfin for 60 seconds and check date again"
spawn ./poweroff_board_as_root $output_pin
while 1 {
   expect {
      timeout {
         report "ERROR: Failed to power off target board, poweroff script didn't work"
         all_done
      }

      eof {
         break
      }
   }
}

puts "Ok, now wait for 60 seconds..."
# reset holds power off for 1 second, so use one less...
sleep 59

spawn ./reset_board_as_root $output_pin
while 1 {
   expect {
      timeout {
         report "ERROR: Failed to reset target board, reset script didn't work"
         recover
         break
      }

      eof {
         break
      }
   }
}
set spawn_id $kermit_spawn_id

step "Wait for uboot countdown"
while 1 {
   expect {

      "Hit any key to stop" {
         send "\r"
         break
      }

      timeout {
         report "ERROR: Failed to reset board, no response"
         all_done
      }
   }
}
wait_for_uboot

set timeout 6
send "date\r"
set time_test_result $TEST_FAIL
set date_test_result $TEST_FAIL
while 1 {
   expect {

      "2003-02-14 (Friday)" {
         set date_test_result $TEST_PASS
      }

      # The time should be about one minute later
      "9:16:" {
         set time_test_result $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot got lost during the date 1-minute test"
         recover
         break
      }
   }
}
record_test_result $date_set_after_power_cycle_loc $date_test_result
record_test_result $time_set_after_power_cycle_loc $time_test_result



step "help"
set timeout 5
# check for several specific lines of help
set autoscr_help $TEST_FAIL
set base_help $TEST_FAIL
set bdinfo_help $TEST_FAIL
set bootelf_help $TEST_FAIL
set flinfo_help $TEST_FAIL
set saveenv_help $TEST_FAIL
set tftpboot_help $TEST_FAIL
set version_help $TEST_FAIL

send "help\r"
while 1 {
   expect {

      "autoscr*-*run script from memory" {
         set autoscr_help $TEST_PASS
      }

      "base*-*print or set address offset" {
         set base_help $TEST_PASS
      }

      "bdinfo*-*print Board Info structure" {
         set bdinfo_help $TEST_PASS
      }

      "bootelf*-*Boot from an ELF image in memory" {
         set bootelf_help $TEST_PASS
      }

      "flinfo*-*print FLASH memory information" {
         set flinfo_help $TEST_PASS
      }

      "saveenv*-*save environment variables to persistent storage" {
         set saveenv_help $TEST_PASS
      }

      "tftpboot*-*boot image via network using TFTP protocol" {
         set tftpboot_help $TEST_PASS
      }

      "version*-*print monitor version" {
         set version_help $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot got lost when sending help command, ironic"
         recover
         break
      }
   }
}

if { $autoscr_help==$TEST_PASS && $base_help==$TEST_PASS && \
         $bdinfo_help==$TEST_PASS && $bootelf_help==$TEST_PASS && \
         $flinfo_help==$TEST_PASS && $saveenv_help==$TEST_PASS && \
         $tftpboot_help==$TEST_PASS && $version_help==$TEST_PASS } {
   set temp_status_flag $TEST_PASS
} else {
   report "Since the help command failed, here are the details:"
   report "autoscr result is $autoscr_help"
   report "base result is $base_help"
   report "bdinfo result is $bdinfo_help"
   report "bootelf result is $bootelf_help"
   report "flinfo result is $flinfo_help"
   report "saveenv result is $saveenv_help"
   report "tftpboot result is $tftpboot_help"
   report "version result is $version_help"
   set temp_status_flag $TEST_FAIL
}
record_test_result $help_loc $temp_status_flag



step "flinfo"
set timeout 10
send "flinfo\r"
set flinfo_mfgr_result $TEST_FAIL
set flinfo_bank_count 0
while 1 {
   expect {

      # This will change for different boards.
      # a bank starts with "20" followed by 3 hex digits, then 3 zeros.
      -re "20\[0-9A-F]\[0-9A-F]\[0-9A-F]000" {
         incr flinfo_bank_count
      }

      "Bank*1:*$FLASH_MFGR" {
         set flinfo_mfgr_result $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot got lost when sending flinfo"
         recover
         break
      }
   }
}
if { $flinfo_bank_count == $NUMBER_OF_FLASH_BANKS } {
   set flinfo_bank_count $TEST_PASS
} else {
   set flinfo_bank_count $TEST_FAIL
   report "flinfo bank count: should be $NUMBER_OF_FLASH_BANKS but was actually $flinfo_bank_count"
}
record_test_result $flinfo_mfgr_loc $flinfo_mfgr_result
record_test_result $flinfo_bank_count_loc $flinfo_bank_count



step "mw"
set timeout 5
# write a long value to 0x1000 consecutive locations.
send "mw.l 0x1000000 1234DEAD 0x1000\r"

wait_for_uboot

set write_result $TEST_FAIL
send "md.w 0x1003FF0\r"
while 1 {
   expect {

      # check that the result is correct near the end of the range.
      "01003ff0:*dead 1234 dead 1234 dead 1234 dead 1234*..4...4...4...4." {
         puts "we saw the correct thing written to memory"
         send_log "we saw the correct thing written to memory\n"
         set write_result $TEST_PASS
      }

      # make sure we didn't write too many locations.
      "01004000: dead" {
         report "oops, we wrote too many bytes"
         set write_result $TEST_FAIL
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot got lost when reading memory"
         recover
         break
      }
   }
}
record_test_result $mwl_loc $write_result



step "nm.w"
set NM_WORD_TO_WRITE  "5b18"
set timeout 5
set temp_status_flag $TEST_FAIL
send "nm.w 0x1000204\r"
while 1 {
   expect {

      "01000204:* \? " {
         set temp_status_flag $TEST_PASS
         break
      }

      $UBOOT_PROMPT {
         report "ERROR: nm command simply returned the uboot prompt"
         break
      }

      timeout {
         report "ERROR: Uboot got lost when doing an nm command"
         recover
         break
      }
   }
}
if {$temp_status_flag == $TEST_PASS } {
   set temp_status_flag $TEST_FAIL
   send "$NM_WORD_TO_WRITE\r"
   while 1 {
      expect {

         "01000204: $NM_WORD_TO_WRITE \? " {
            set temp_status_flag $TEST_PASS
            break
         }

         timeout {
            puts "nm.w failed to write a value"
            send_log "nm.w failed to write a value"
            break
         }
      }
   }
}

# send control-C to escape out of the nm command.
send "\003"

wait_for_uboot

# go back and verify that it was actually written.
if { $temp_status_flag == $TEST_PASS } {
   set temp_status_flag $TEST_FAIL
   send "md 0x1000200\r"
   while 1 {
      expect {

         -re "01000200: ........ ....$NM_WORD_TO_WRITE " {
            set temp_status_flag $TEST_PASS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: Uboot failed to respond to a control-C"
            recover
            break
         }
      }
   }
}
record_test_result $nm_loc $temp_status_flag



step "mm"
set timeout 5
set temp_status_flag $TEST_FAIL

send "mm.w 0x1000000\r"
while 1 {
   expect {

      "01000000:*\? " {
         set temp_status_flag $TEST_PASS
         break
      }

      $UBOOT_PROMPT {
         report "ERROR: mm.w returned to uboot prompt"
         break
      }

      timeout {
         report "ERROR: Uboot got lost when writing to memory using mm"
         break
      }
   }
}
if { $temp_status_flag == $TEST_PASS } {

   for {set i 0} {$i < $MM_ITERATIONS && $temp_status_flag==$TEST_PASS} \
{incr i} {
      send $i\r
      while 1 {
         expect {

            "0100*:*\? " {
               break
            }

            $UBOOT_PROMPT {
               report "ERROR: mm.w returned to uboot prompt"
               set temp_status_flag $TEST_FAIL
               break
            }

            timeout {
               report "ERROR: Uboot or the test script got lost when \
writing to memory"
               set temp_status_flag $TEST_FAIL
               break
            }
         }
      }
   }

   # send control-C
   send "\003"

   wait_for_uboot

}

if {$temp_status_flag==$TEST_PASS} {

   set temp_status_flag $TEST_FAIL
   set timeout 5
   send "md 0x1000000\r"
   while 1 {
      expect {

         "01000030:*00250024 00270026 00290028 00310030" {
            set temp_status_flag $TEST_PASS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            break
         }
      }
   }
}
record_test_result $mm_loc $temp_status_flag



step "reset command"
set timeout 5
set reset_good_count 0
set reset_bad_count 0
for {set i 0} { $i<$RESET_ITERATIONS} {incr i} {
   set temp_status_flag $TEST_FAIL

   send "reset\r"

   while 1 {
      expect {

         "Hit any key to stop" {
            send "\r"
            set temp_status_flag $TEST_PASS
            break
         }

         timeout {
            recover
            break
         }
      }
   }

   wait_for_uboot

   if {$i < 2} {
      # for some of the attempts, sleep 2 and do a help command
      # just to avoid immediately resetting again.
      sleep 2
      send "help\r"
      while 1 {
         expect {

            $UBOOT_PROMPT {
               break
            }

            timeout {
               recover
            } 
         }
      }
   }

   if {$temp_status_flag == $TEST_PASS} {
      incr reset_good_count
   } else {
      incr reset_bad_count
   }
}
if {$reset_good_count == $RESET_ITERATIONS && $reset_bad_count == 0} {
   set reset_result $TEST_PASS
} else {
   report "reset command Successes=$reset_good_count, Failures=$reset_bad_count"
   set reset_result $TEST_FAIL
}
record_test_result $reset_loc $reset_result



step "reset the board again in case the reset command killed the board"
spawn ./reset_board_as_root $output_pin
while 1 {
   expect {
      timeout {
         report "ERROR: Failed to reset target board, reset script didn't work"
         all_done
      }

      eof {
         break
      }
   }
}
set spawn_id $kermit_spawn_id

while 1 {
   expect {

      "Hit any key to stop" {
         send "\r"
         break
      }

      timeout {
         report "ERROR: Failed to reset board, no response"
         recover
         break
      }
   }
}
wait_for_uboot



step "Set up environment variables"
set timeout 6

send "set ipaddr $target_ip_addr\r"
wait_for_uboot

send "set serverip $HOST_IP_ADDR\r"
wait_for_uboot

send "set gatewayip $HOST_IP_ADDR\r"
wait_for_uboot

send "set linuxrun bootm $KERNEL_FLASH_LOC\r"
wait_for_uboot

send "set bootcmd run linuxrun\r"
wait_for_uboot

send "set dhcp_boot dhcp\\;bootelf 0x1000000\\;echo\r"
wait_for_uboot

send "set tftp_boot tftp 0x1000000 $LINUX_DXE_FILE\\;bootm 0x1000000;echo\r"
wait_for_uboot

send "set bootdelay 9\r"
wait_for_uboot



step "Save environment variables"
set timeout 300
set saveenv_time_max 0
set saveenv_time_min $timeout
set saveenv_time_sum 0

for {set i 0} {$i < $SAVEENV_ITERATIONS} {incr i} {
   send "saveenv\r"
   set temp_time [time {
      while 1 {
         expect {

            "Erasing" { }

            "Writing" { }

            $UBOOT_PROMPT {
               break
            }

            timeout {
               report "ERROR: Uboot got lost when saving environment variables"
               recover
               break
            }
         }
      }
   }]
   set temp_time [convert_to_seconds $temp_time]
   if {$temp_time > $saveenv_time_max} {
      set saveenv_time_max $temp_time
   }
   if {$temp_time < $saveenv_time_min} {
      set saveenv_time_min $temp_time
   }
   set saveenv_time_sum [expr $saveenv_time_sum + $temp_time]
}
set saveenv_time_ave [expr $saveenv_time_sum / $SAVEENV_ITERATIONS]

record_test_measurement $max_saveenv_time_loc $saveenv_time_max
record_test_measurement $min_saveenv_time_loc $saveenv_time_min
record_test_measurement $ave_saveenv_time_loc $saveenv_time_ave



step "ping test"
set timeout 20
set ping_successes 0
set ping_failures 0
set max_ping_cmd_time 0
set min_ping_cmd_time $timeout
set sum_ping_cmd_time 0

for {set i 0} {$i < $PING_ITERATIONS} { incr i } {
   set ping_status $TEST_FAIL
   send "ping $HOST_IP_ADDR\r"

   set temp_time [time {
      while 1 {
         expect {

            "is alive" {
               puts "\ngot a good ping response"
               set ping_status $TEST_PASS
               incr ping_successes
            }

            $UBOOT_PROMPT {
               if {$ping_status==$TEST_FAIL} {
                  incr ping_failures
               }
               break
            }

            timeout {
               incr ping_failures
               report "WARNING: Uboot hung on ping command"
               recover
               break
            }
         }
      }
   }]

   set ping_cmd_time [convert_to_seconds $temp_time]
   puts "ping took $ping_cmd_time seconds to complete"
   send_log "ping took $ping_cmd_time seconds to complete"

   set sum_ping_cmd_time [expr $ping_cmd_time + $sum_ping_cmd_time]
   if { $ping_cmd_time > $max_ping_cmd_time } {
      set max_ping_cmd_time $ping_cmd_time
   }
   if { $ping_cmd_time < $min_ping_cmd_time } {
      set min_ping_cmd_time $ping_cmd_time
   }
}
set ave_ping_cmd_time [expr $sum_ping_cmd_time / $PING_ITERATIONS]

report "ping test: Passes=$ping_successes, Failures=$ping_failures"
if {$ping_successes==$PING_ITERATIONS && $ping_failures==0} {
   set ping_result $TEST_PASS
} else {
   set ping_result $TEST_FAIL
}
record_test_measurement $ping_command_time_max_loc $max_ping_cmd_time
record_test_measurement $ping_command_time_min_loc $min_ping_cmd_time
record_test_measurement $ping_command_time_ave_loc $ave_ping_cmd_time
record_test_result $ping_loc $ping_result



step "autoscr"
set timeout 20
send "tftp 0x1000000 $AUTOSCR_TEST_FILE\r"
set temp_status_flag $FAILURE
while 1 {
   expect {

      "#" { }

      "Bytes transferred" {
         set temp_status_flag $SUCCESS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot is in some weird state after starting"
         recover
         break
      }
   }
}
if { $temp_status_flag == $FAILURE } {
   report "INFO: Can't execute autoscr test because tftp didn't work."
} else {

   send "autoscr\n"
   set temp_status_flag $TEST_FAIL
   while 1 {
      expect {

         $AUTOSCR_TEST_RESULT {
            set temp_status_flag $TEST_PASS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: Uboot is in some weird state during test"
            recover
            break
         }
      }
   }
   record_test_result $autoscr_loc $temp_status_flag
}



step "base test"
set timeout 20
send "base\r"
set temp_status_flag $TEST_FAIL
while 1 {
   expect {

      "Base Address: $BASE_RESULT" {
         set temp_status_flag $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot is in some weird state during test"
         recover
         break
      }
   }
}
record_test_result $base_loc $temp_status_flag



step "bdinfo test"
set timeout 7

set memstart_result    $TEST_FAIL
set memsize_result     $TEST_FAIL
set flashstart_result  $TEST_FAIL
set flashsize_result   $TEST_FAIL
set flashoffset_result $TEST_FAIL
set ethaddr_result     $TEST_FAIL
set ip_addr_result     $TEST_FAIL
set baudrate_result    $TEST_FAIL
send "bdinfo\r"

while 1 {
   expect {

      "memstart *= $BDINFO_MEMSTART" {
         set memstart_result $TEST_PASS
      }

      "memsize *= $BDINFO_MEMSIZE" {
         set memsize_result $TEST_PASS
      }

      "flashstart *= $BDINFO_FLASHSTART" {
         set flashstart_result $TEST_PASS
      }

      "flashsize *= $BDINFO_FLASHSIZE" {
         set flashsize_result $TEST_PASS
      }

      "flashoffset *= $BDINFO_FLASHOFFSET" {
         set flashoffset_result $TEST_PASS
      }

      "ethaddr *= \[A-F0-9]\[A-F0-9]:\[A-F0-9]\[A-F0-9]:\[A-F0-9]\[A-F0-9]:\[A-F0-9]\[A-F0-9]:\[A-F0-9]\[A-F0-9]:\[A-F0-9]\[A-F0-9]" {
         set ethaddr_result $TEST_PASS
      }

      -re "ip_addr.*= \[A-F0-9]+\.\[A-F0-9]+\.\[A-F0-9]+\.\[A-F0-9]+" {
         set ip_addr_result $TEST_PASS
      }

      "baudrate *= $BDINFO_BAUDRATE bps" {
         set baudrate_result $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot is in some weird state during test"
         recover
         break
      }
   }
}
if {$memstart_result==$TEST_PASS && $memsize_result==$TEST_PASS \
&& $flashstart_result==$TEST_PASS && $flashsize_result==$TEST_PASS \
&& $flashoffset_result==$TEST_PASS && $ethaddr_result==$TEST_PASS \
&& $ip_addr_result==$TEST_PASS && $baudrate_result==$TEST_PASS} {
   set bdinfo_result $TEST_PASS
} else {
   set bdinfo_result $TEST_FAIL
   report "bdinfo memstart result: $memstart_result"
   report "bdinfo memsize result: $memsize_result"
   report "bdinfo flashstart result: $flashstart_result"
   report "bdinfo flashsize result: $flashsize_result"
   report "bdinfo flashoffset result: $flashoffset_result"
   report "bdinfo ethaddr result: $ethaddr_result"
   report "bdinfo ip_addr result: $ip_addr_result"
   report "bdinfo baudrate result: $baudrate_result"
}
record_test_result $bdinfo_loc $bdinfo_result



step "iminfo"
set timeout 20
send "tftp 0x1000000 $KERNEL_GZ_FILENAME\r"
set temp_status_flag $TEST_FAIL
while 1 {
   expect {

      "invalid RARP" {
         send_log "TFTP-ERROR\n"
         incr tftp_errors
      }

      "# T" {
         send_log "TFTP-ERROR\n"
         incr tftp_errors
      }

      "TFTP error" {
         send_log "TFTP-ERROR\n"
         incr tftp_errors
      }

      "T #" {
         send_log "TFTP-ERROR\n"
         incr tftp_errors
      }

      "#" { }

      $UBOOT_PROMPT {
         set temp_status_flag $TEST_PASS
         break
      }

      timeout {
         report "ERROR: tftp failed to execute, can't run bootelf test"
         recover
         break
      }
   }
}
if {$temp_status_flag==$TEST_PASS} {
   puts "testing out iminfo"
   set iminfo_name_result $TEST_FAIL
   set iminfo_date_result $TEST_FAIL
   set iminfo_type_result $TEST_FAIL
   set iminfo_size_result $TEST_FAIL
   set iminfo_addr_result $TEST_FAIL
   set iminfo_entry_result $TEST_FAIL
   set iminfo_checksum_result $TEST_FAIL
   set timeout 7
   send "iminfo\r"
   while 1 {
      expect {

         "Image Name:*$KERNEL_GZ_NAME" {
            set iminfo_name_result $TEST_PASS
         }

         "Created:*$KERNEL_GZ_DATE" {
            set iminfo_date_result $TEST_PASS
         }

         "Image Type:*$KERNEL_GZ_TYPE" {
            set iminfo_type_result $TEST_PASS
         }

         "Data Size:*$KERNEL_GZ_SIZE" {
            set iminfo_size_result $TEST_PASS
         }

         "Load Address:*$KERNEL_GZ_ADDR" {
            set iminfo_addr_result $TEST_PASS
         }

         "Entry Point:*$KERNEL_GZ_ENTRY" {
            set iminfo_entry_result $TEST_PASS
         }

         "Verifying Checksum ... OK" {
            set iminfo_checksum_result $TEST_PASS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            break
         }
      }
   }

   if {$iminfo_name_result==$TEST_PASS && $iminfo_date_result==$TEST_PASS \
   && $iminfo_type_result==$TEST_PASS && $iminfo_size_result==$TEST_PASS \
   && $iminfo_addr_result==$TEST_PASS && $iminfo_entry_result==$TEST_PASS \
   && $iminfo_checksum_result==$TEST_PASS} {
      set iminfo_result $TEST_PASS
   } else {
      set iminfo_result $TEST_FAIL
      report "iminfo name: $iminfo_name_result"
      report "iminfo date: $iminfo_date_result"
      report "iminfo type: $iminfo_type_result"
      report "iminfo size: $iminfo_size_result"
      report "iminfo addr: $iminfo_addr_result"
      report "iminfo entry: $iminfo_entry_result"
      report "iminfo checksum: $iminfo_checksum_result"
   }
} else {
   report "iminfo: INFO: can't run the test because tftp failed"
}
record_test_result $iminfo_loc $iminfo_result



step "bootelf"
set timeout 20
send "tftp 0x1000000 $LINUX_DXE_FILE\r"
while 1 {
   expect {

      "invalid RARP" {
         send_log "TFTP-ERROR\n"
         incr tftp_errors
      }

      "# T" {
         send_log "TFTP-ERROR\n"
         incr tftp_errors
      }

      "TFTP error" {
         send_log "TFTP-ERROR\n"
         incr tftp_errors
      }

      "T #" {
         send_log "TFTP-ERROR\n"
         incr tftp_errors
      }

      "#" { }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: tftp failed to execute, can't run bootelf test"
         recover
         break
      }
   }
}

send "bootelf\r"
set bootelf_result $TEST_FAIL
while 1 {
   expect {

      $KERNEL_PROMPT {
         set bootelf_result $TEST_PASS
         break
      }

      timeout {
         report "WARNING: Never got kernel prompt in bootelf test"
         break
      }
   }
}
record_test_result $bootelf_loc $bootelf_result



step "Reset the board and check if env variables are still set"
#  (remember that we still have the kermit session open)
spawn ./reset_board_as_root $output_pin
while 1 {
   expect {
      timeout {
         report "ERROR: Failed to reset target board, reset script didn't work"
         all_done
      }

      eof {
         break
      }
   }
}

#  Now go back to the kermit session
set spawn_id $kermit_spawn_id

while 1 {
   expect {

      "Hit any key to stop" {
         send "\r"
         break
      }

      timeout {
         report "ERROR: board failed to reset, it worked before"
         recover
         break
      }
   }
}

wait_for_uboot

sleep 1
send "printenv\r"
set temp_status_flag $TEST_FAIL
while 1 {
   expect {

      "gatewayip=$HOST_IP_ADDR" {
         set temp_status_flag $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: uboot got lost setting an env variable: set tftp_boot"
         recover
         break
      }
   }
}
record_test_result $savenv_loc $temp_status_flag
record_test_result $printenv_loc $temp_status_flag



step "protect on"
set timeout 5
send "protect on all\r"
wait_for_uboot

set protect_on_result $TEST_FAIL
set timeout 30
send "cp.b 0x1000000 0x20100000 0x200\r"
while 1 {
   expect {

      "Can't write to protected" {
         set protect_on_result $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "FATAL ERROR: copy to flash took too long during protect test"
         all_done
      }
   }
}
record_test_result $protect_on_loc $protect_on_result



step "protect off"
set protect_off_result $TEST_FAIL
set timeout 5
send "protect off all\r"
wait_for_uboot

set timeout 120
send "erase 0x20100000 0x2010FFFF\r"
wait_for_uboot
set protect_off_result $TEST_FAIL
set timeout 30
send "cp.b 0x1000000 0x20100000 0x200\r"
while 1 {
   expect {

      "done" {
         set protect_off_result $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "FATAL ERROR: copy to flash took too long \
during protect test"
         all_done
      }
   }
}
if {$protect_off_result == $TEST_PASS} {
   send "cmp.b 0x1000000 0x20100000 0x200\r"
   set protect_off_result $TEST_FAIL
   while 1 {
      expect {

         "Total of 512 bytes were the same" {
            set protect_off_result $TEST_PASS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: cmp.b got lost"
            recover
            break
         }
      }
   }
}
record_test_result $protect_off_loc $protect_off_result



#
# In this test, tftp a file into RAM, then copy it to another part
# of RAM, then verify the two parts compare the same, then modify
# the very last byte of the range and the next byte (which is outside
# the range) and verify that there is only 1 byte different within
# the range.
#
step "cmp"
set timeout 20
set temp_status_flag $FAILURE
set cp_result $TEST_INFO
set cmp_result $TEST_INFO
send "tftp 0x1000000 $TEST_BIN_FILE\r"
while 1 {
   expect {

      "#" { }

      "Bytes transferred" {
         set temp_status_flag $SUCCESS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "ERROR: Uboot is in some weird state during tftp."
         recover
         break
      }
   }
}
if { $temp_status_flag == $FAILURE } {
   report "INFO: Can't execute cmp test because tftp didn't work."
} else {

   set timeout 10
   send "cp.b 0x1000000 0x1020000 0x10000\r"
   wait_for_uboot

   set timeout 5
   set temp_status_flag $TEST_FAIL
   send "cmp.b 0x1000000 0x1020000 0x10000\r"
   while 1 {
      expect {

         "65536" {
            set temp_status_flag $TEST_PASS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: cmp.b took way too long during cp and cmp test"
            recover
            break
         }
      }
   }
   if {$temp_status_flag == $TEST_PASS} {
      set timeout 5
      set temp_status_flag 0
      send "mm.b 0x100FFFF\r"
      while 1 {
         expect {

            "0100ffff:" {
               send "f1\r"
               puts "\nNOTE: this should be setting the \
byte to something different"
               set temp_status_flag 1
            }

            "01010000:" {
               send "f1\r"
               puts "\nNOTE: this should be setting the \
byte to something different"
               if {$temp_status_flag == 1} {
                  set temp_status_flag 2
               }
            }

            "01010001:" {
               # send a control-C
               send "\003"
               if {$temp_status_flag ==2} {
                  set temp_status_flag 3
               }
            }

            $UBOOT_PROMPT {
               break
            }

            timeout {
               report "there was a testing problem during \
the cp and cmp test"
               recover
               break
            }
         }
      }
      if {$temp_status_flag == 3} {

         set timeout 5
         set temp_status_flag $TEST_FAIL
         send "cmp.b 0x1000000 0x1020000 0x10000\r"
         while 1 {
            expect {

               # should be one byte less than before
               "65535" {
                  set temp_status_flag $TEST_PASS
               }

               "65536" {
                  report "cmp.b isn't detecting a modified byte"
               }

               "65534" {
                  report "cmp.b is checking one too many bytes"
               }

               $UBOOT_PROMPT {
                  break
               }

               timeout {
                  report "ERROR: cmp.b took way too long \
during cp and cmp test"
                  recover
                  break
               }
            }
         }
         record_test_result $cmp_loc $temp_status_flag

      } else {
         record_test_result $cmp_loc $TEST_INFO
      }
   } else {
      record_test_result $cmp_loc $TEST_FAIL
   }
}




step "cp RAM-to-RAM, aligned"
set cp_result [copy_test 1000000 $COPY_TEST_RAM 1010004 $COPY_TEST_RAM \
1010000 101F004 F000 61440 0 0 0 0]
record_test_result $cp_RAM_to_RAM_aligned_loc $cp_result

step "cp RAM-to-RAM, unaligned"
set cp_result [copy_test 1000001 $COPY_TEST_RAM 1010005 $COPY_TEST_RAM \
1010001 101F005 F000 61440 0 0 0 0]
record_test_result $cp_RAM_to_RAM_unaligned_loc $cp_result

step "cp flash-to-flash, aligned"
set cp_result [copy_test 203F0000 $COPY_TEST_FLASH 203E0004 $COPY_TEST_FLASH \
203E0000 203EF004 F000 61440 203F0000 203FFFFF 203E0000 203EFFFF]
record_test_result $cp_flash_to_flash_aligned_loc $cp_result

step "cp flash-to-flash, unaligned"
set cp_result [copy_test 203F0001 $COPY_TEST_FLASH 203E0005 $COPY_TEST_FLASH \
203E0001 203EF005 F000 61440 203F0000 203FFFFF 203E0000 203EFFFF]
record_test_result $cp_flash_to_flash_unaligned_loc $cp_result

step "cp flash-to-RAM, aligned"
set cp_result [copy_test 203F0000 $COPY_TEST_FLASH 1010004 $COPY_TEST_RAM \
1010000 101F004 F000 61440 203F0000 203FFFFF 0 0]
record_test_result $cp_flash_to_RAM_aligned_loc $cp_result

step "cp flash-to-RAM, unaligned"
set cp_result [copy_test 203F0001 $COPY_TEST_FLASH 1010005 $COPY_TEST_RAM \
1010001 101F005 F000 61440 203F0000 203FFFFF 0 0]
record_test_result $cp_flash_to_RAM_unaligned_loc $cp_result

step "cp RAM-to-flash, aligned"
set cp_result [copy_test 1000000 $COPY_TEST_RAM 203E0004 $COPY_TEST_FLASH \
203E0000 203EF004 F000 61440 0 0 203E0000 203EFFFF]
record_test_result $cp_RAM_to_flash_aligned_loc $cp_result

step "cp RAM-to-flash, unaligned"
set cp_result [copy_test 1000001 $COPY_TEST_RAM 203E0005 $COPY_TEST_FLASH \
203E0001 203EF005 F000 61440 0 0 203E0000 203EFFFF]
record_test_result $cp_RAM_to_flash_unaligned_loc $cp_result



step "run"
set timeout 5
send "setenv bad_command xyz\r"
wait_for_uboot

set timeout 5
set temp_status_flag $TEST_FAIL
send "run bad_command\r"
while 1 {
   expect {

      "Unknown command 'xyz'" {
         set temp_status_flag $TEST_PASS
      }

      $UBOOT_PROMPT {
         break
      }

      timeout {
         report "FATAL ERROR: uboot got lost setting an environment variable"
         all_done
      }
   }
}
record_test_result $run_loc $temp_status_flag



step "mtest"
set timeout 60
set counter_1 0
set counter_2 0
set MTEST_ITERATIONS 32
send "mtest 0x1000000 0x1010000 0xFFFF\r"
while 1 {

   if { $counter_1 > $MTEST_ITERATIONS } {
      break
   }
   if { $counter_2 > $MTEST_ITERATIONS } {
      break
   }

   expect {

      "Pattern 000*Writing...*Reading..." {
         incr counter_1
      }

      "Pattern FFF*Writing...*Reading..." {
         incr counter_2
      }

      $UBOOT_PROMPT {
         report "mtest jumped back to the uboot prompt before $timeout seconds"
         break
      }

      timeout {
         report "mtest didn't result in at least $MTEST_ITERATIONS cycles within $timeout seconds"
         break
      }
   }
}
if { $counter_1 < $MTEST_ITERATIONS || $counter_2 < $MTEST_ITERATIONS } {
   set mtest_result $TEST_FAIL
   report "normal pattern cycles=$counter_1, compliment pattern cycles=$counter_2"
} else {
   set mtest_result $TEST_PASS
}
record_test_result $mtest_loc $mtest_result


# Send a control-C to stop the mtest.
send "\3"
wait_for_uboot



step "do tftp $TFTP_ITERATIONS times"
set timeout 30
#
# Note: the tftp error counter can by incremented at various
#  place in the code above, so don't reset it to zero here.
#  But the good transfers flag should be reset.
#
set good_tftp_transfers 0
for {set i 0} {$i < $TFTP_ITERATIONS} {incr i} {
   send "tftp $TFTP_LOAD_ADDR $KERNEL_GZ_FILENAME\r"
   while 1 {
      expect {

         "Bytes transferred" {
            incr good_tftp_transfers
         }

         "invalid RARP" {
            report "invalid RARP error in tftp detected"
            send_log "TFTP-ERROR\n"
            incr tftp_errors
         }
  
         "# T" {
            report "tftp timeout detected"
            send_log "TFTP-ERROR\n"
            incr tftp_errors
         }

         "TFTP error" {
            report "TFTP error detected"
            send_log "TFTP-ERROR\n"
            incr tftp_errors
         }

         "T #" {
            report "tftp timeout detected"
            send_log "TFTP-ERROR\n"
            incr tftp_errors
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "ERROR: tftp timed out"
            send_log "TFTP-ERROR\n"
            incr tftp_errors
            recover
            break
         }
      }
   }
}
if {$tftp_errors == 0} {
   record_test_result $tftp_errors_loc $TEST_PASS
} else {
   send_log "\ntftp_errors = $tftp_errors\n\n"
   record_test_result $tftp_errors_loc $TEST_FAIL
}
if {$good_tftp_transfers == $TFTP_ITERATIONS} {
   record_test_result $tftp_loc $TEST_PASS
} else {
   record_test_result $tftp_loc $TEST_FAIL
}

if {$good_tftp_transfers == 0} {
   report "can't do the kernel flash and boot test \
because tftp never worked"
} else {
   step "Load kernel info flash"
   set timeout 180
   send "erase $KERNEL_FLASH_LOC $KERNEL_FLASH_END\r"
   set temp_status_flag $FAILURE
   while 1 {
      expect {

         "Erased * sectors" {
            set temp_status_flag $SUCCESS
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            puts "ERROR: Didn't seem to erase flash"
            break
         }
      }
   }
   if {$temp_status_flag != $SUCCESS } {
      report "Failed to erase flash"
      all_done
   }

   sleep 1
   set timeout 1200
   puts "\nAbout to copy the kernel to flash."
   send "cp.b $TFTP_LOAD_ADDR $KERNEL_FLASH_LOC $KERNEL_FLASH_SIZE\r"
   set temp_status_flag $FAILURE
   while 1 {
      expect {

         "done" {
            set temp_status_flag $SUCCESS
         }

         "?lash not ?rased" {
            set temp_status_flag $FAILURE
            report "ERROR: Tried to copy kernel to flash, got error, not erased"
         }

         $UBOOT_PROMPT {
            break
         }

         timeout {
            report "FATAL ERROR: Not able to erase flash"
            all_done
         }
      }
   }
   if { $temp_status_flag == $SUCCESS } {
      set do_bootm_test $TEST_PASS
      puts "copying kernel to flash seemed to work"
      send_log "copying kernel to flash seemed to work\n"
   } else {
      set do_bootm_test $TEST_FAIL
      report "WARNING: copying kernel to flash didn't seem to work, can't do bootm test"
   }

   step "Reset the board and boot from flash"
   set timeout 60
   spawn ./reset_board_as_root $output_pin
   while 1 {
      expect {
         timeout {
            report "ERROR: Failed to reset target board, reset script didn't work"
            all_done
         }

         eof {
            break
         }
      }
   }  

   #  Now go back to the kermit session
   set spawn_id $kermit_spawn_id

   while 1 {
      expect {

         "Hit any key to stop" {
            break
         }

         timeout {
            report "ERROR: board failed to reset, it worked before"
            recover
            break
         }
      }
   }


   if {$do_bootm_test==$TEST_PASS} {
      set temp_status_flag $TEST_FAIL
      while 1 {
         expect {

            $KERNEL_PROMPT {
               set temp_status_flag $TEST_PASS
               # wait for the actual prompt itself.
               sleep 1
               break
            }

            timeout {
               report "WARNING: kernel never booted from flash"
               break
            }
         }
      }

      if { $temp_status_flag == $TEST_PASS } {
         step "Make sure kernel is functional"

         set timeout 30
         send "ls\r"
         set temp_status_flag $TEST_FAIL
         while 1 {
            expect {

               "sbin" {
                  puts "we got an indication that the kernel is working"
                  send_log "we got an indication that the kernel is working\n"
                  set temp_status_flag $TEST_PASS
                  break
               }
 
               $KERNEL_PROMPT {
                  break
               }

               timeout {
                  send_log "\nERROR: Kernel never responded correctly"
                  break
               }
            }
         }
      }
      record_test_result $boot_from_flash_loc $temp_status_flag
   }
}



step "Reset the board"
set timeout 30
spawn ./reset_board_as_root $output_pin
while 1 {
   expect {

      timeout {
         report "ERROR: Failed to reset target board, reset script didn't work"
         all_done
      }

      eof {
         break
      }
   }
}

#  Now go back to the kermit session
set spawn_id $kermit_spawn_id

while 1 {
   expect {

      "Hit any key to stop" {
         send "\r"
         break
      }

      timeout {
         report "FATAL ERROR: board failed to reset, it worked before"
         recover
         break
      }
   }
}
wait_for_uboot

all_done
